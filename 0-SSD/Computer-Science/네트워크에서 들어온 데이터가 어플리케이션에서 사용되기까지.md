- 먼저 네트워크에서 데이터가 들어오면 nic에서 데이터를 받아 kernel buffer에 저장함
	- 이때 데이터를 처리하는 방식이 4가지 존재  [링크](https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/nic.htm)
		- 데이터가 들어오면 바로 interrupt를 발생시켜 mainboard의 cpu를 사용하는방식
		- NIC의 cpu를 사용해서 데이터를 저장하고 저장이 끝나면 interrupt를 발생시키는 방식

- 커널 버퍼에 있는 데이터를 실제 사용할 프로세스에 전달하는 과정
	- 커널버퍼와 유저버퍼가 따로있다
		- 커널버퍼는 모든 프로세스가 사용할수 있는 공유공간
		- 유저버퍼는 우리가 실행한 프로세스가 사용하는 공간
	- 커널버퍼에 있는 데이터를 유저버퍼에 가져오려면 system call을 호출해야함
	- 어떤 system call을 사용하느냐에 따라 blocking, non-blocking이 나눠짐
		- blocking 방식
			- blocking방식에서는 accept를 바로 호출하고, 쓰레드는 데이터를 가져올 때까지 계속 대기함
		- non-blocking 방식
			- non-blocking방식에서는 select, epoll, io_uring 등의 방식을 사용
			-  바로 accept를 호출하는 것이 아니라, 소켓에서 변경이 발생했는지 여부를 먼저 확인하고 변경이 발생하면 accept를 호출함
			- select
			- epoll
			- io_uring

이걸 커널에 시스템콜 <- 이떄 컨택스트 스위치 발생 operating system concepts p.494
커널버퍼에 쌓음
async일때는 커널버퍼에서 언제 가져오냐가 문제가됨 <- system call 이 필요하므로 컨택스트 스위치 발
	select는 매번 확인해야함
	epoll은 커널에서 변경 발생시 알려줌
	io_uring
동기방식에서는 read메서드를 호출하면 데이터가 올떄까지 계속 대기하는 방식
비동기방식에서는 read를 호출하면 데이터가 올떄까지 대기하지 않고 리턴해

sync일때는 커널버퍼에서 뭘 호출하는가? 아니면 계속확인하는
async일때는 다른작업 하다가 체크함
 시간이 날때 커널버퍼에서 데이터를 가져옴


https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/

https://www.youtube.com/watch?v=uagKTbohimU&list=PLBlnK6fEyqRgKl0MbI6kbI5ffNt7BF8Fn&index=13

https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/nic.htm
https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/hyperlin.htm

https://d2.naver.com/helloworld/47667

https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part1

https://meetup.nhncloud.com/posts/54#:~:text=%EC%9C%84%EC%97%90%EC%84%9C%20%EB%91%90%20%EA%B0%92%EC%9D%80%20%EA%B0%81%EA%B0%81%20%EC%82%AC%EC%9A%A9%ED%95%A0%20%ED%8F%AC%ED%8A%B8%20%EB%B2%94%EC%9C%84%EC%9D%98,%EC%86%8C%EC%BC%93%20%EC%88%98%EB%8A%94%20%EC%9D%B4%EC%97%90%20%EB%AF%B8%EC%B9%98%EC%A7%80%20%EB%AA%BB%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4
