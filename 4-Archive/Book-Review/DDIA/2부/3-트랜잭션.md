---
created: 2024-03-31T22:41:00
date: 2024-04-13T22:56
---
- 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
## ACID vs BASE
### ACID
- 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Duration)의 약어
	- 원자성
		- 여러쓰기 작업이 하나의 트랜잭션에 묶여있다면 이 쓰기 작업은 성공하거나, 실패하거나 둘중에 하나
		- 애매하개 몇개만 성공하거나 몇개만 실패하는 경우는 없음
	- 일관성
		- 일관되게 보여주어야 하는데 이건 데이터베이스 속성이 아니라 애플리케이션 속성이다.
		- 새로운 관점이네
		- 항상 진실이어야하는, 데이터에 관한 어떤 선언, 불변식이 있다는 것
		- 회계에서 대변과 차변이 맞아야하는
		- 위의 사례는 데이터베이스가 아닌 애플리케이션의 속성임
	- 격리성
		- 동시에 실행되는 트랜잭션은 서로 격리되어 볼 수 없음
	- 지속성
		- 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함은 발생하거나, 데이터베이스가 죽더라도 트랜잭션에 기록된 모든 데이터는 손실되지 않는다
			- redo, undo로그 참고하기
### BASE
- Basically Available
	- 기본적으로 가용성을 제공하고
- Soft state
	- 유연한 상태를 가지며
- Eventual consistency
	- 최종적 일관성을 가진다
### 최종적 일관성
- 복제서버가 10대인 상황에서, 데이터 쓰기가 발생했을때 10대의 서버와 모두 동기화 하려면 가용성이 떨어짐
- 정족수 or 적당한 가용성을 확보할 수 있는 서버 대수를 정하고, 그 서버 대수만 만족하면 나머지는 비동기 처리

### 동시성 제어
- 더티읽기
	- 한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 읽는다
	- 커밋후 읽기 또는 그보다 강한 격리수준에서 방지 가능
- 더티쓰기
	- 한클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지 않은 데이터를 덮어쓴다
	- 모든 트랜잭션구현에서 방지 가능
- 읽기 스큐(비반복 읽기)
	- 클라이언트는 다른 시점에 데이터베이스의 다른 부분은 본다
		- 
- 갱신 손실
	- 클라이언트가 동시에 read-modify-write를 실행했을때, 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 내용을 덮어써서 데이터가 손실됨
	- 수동잠금(select for update) 필요
	- 또는 CAS사용
- 쓰기 스큐
	- 트랜잭션이 무언가로 읽고 읽은값을 기반으로 결정하고 그 결정을 데이터베이스에 
	- ***충돌의 구체화..!!!***
	- 단일 사용자 닉네임
		- 사용자 닉네임이 없는지 확인하고 삽입
		- 하지만 없는지 확인하는 과정과 삽입 사이 다른사람이 데이터 삽입가능
		- 충돌의 구체화
			- 모든 사용자네임을 row로 만들고 읽을때 lock을 검
	- 직렬성 격리로 해결 가능
- 팬텀 읽기
	- 트랜잭션에서 어떤 검색에 부합하는 객체를 읽음
	- 다른 클라이언트가 그 검색결과에 영향을 쓰는 쓰기를 실행
	- 스냅숏 격리로 간단한 읽기는 막아주지만, 완벽히 막기 위해서는 색인범위 잠금이 필요함

### 직렬성 트랜잭션 구현방법
-  말 그래도 트랜잭션을 순서대로 실행
- 2단계 잠금
	- 오랜시간 직렬성을 구현하는 방법이지만, 성능 때문에 사용을 피함
- 직렬성 스냅숏 격리(SSI)
	- 낙관적 방법을 사용해서 트랜잭션이 차단되지 않고 진행할 수 있게해줌
	- 트랜잭션이 커밋을 원할때 트랜잭션을 확인해서 실행이 직렬적이지 않으면 어보트함