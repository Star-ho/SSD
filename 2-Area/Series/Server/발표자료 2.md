---
date: 2024-05-25 22:48:55
updatedAt: 2024-05-27 23:10:57
---
차례
- Virtual Thread가 무엇인가?
- Virtual Thread의 동작원리
- 도입이 가능할까?

## Virtual Thread가 무엇인가?
- 처리량이 많은 동시성 애플리케이션을 작성, 유지관리 및 observing 하는데 드는 수고를 획기적으로 줄여주는 경량쓰레드임
- JDK19에 처음 preview 모델이 나왔고, 2023년 JDK21에 정식 feature로 추가됨
- OS 스레드를 그대로 사용하지 않고 JVM내부 스케줄링을 통해 스레드를 관리

### spring mvc의 Threading 모델
- Thread per request방식으로 하나의 platform 쓰레드를 할당받아 요청을 처리
	- web service에서는 요청은 적은 요청으로 CPU를 많이 사용하는 작업이 아닌, IO가 많은 작업임
	- 그래서 Thread를 생성할 일이 많다
- 요청이 들어올 때마다 Platform Thread를 할당해야함

### 요청당 하나의 Thread를 할당 하지 않는 모델인 reactive모델이 있음
- 코드가 복잡하다
	- 유지보수가 힘들다
	- 에러 파악이 힘들다
- Thread Local을 사용하지 못하는 문제
	- platform thread를 사용하는 것처럼 Thread Local을 사용하지 못한다
		- https://spring.io/blog/2023/03/28/context-propagation-with-project-reactor-1-the-basics
	- Thread Local만을 지원하는 라이브러리 사용 불가
- 자바의 디자인은 thread중심임
	- exception stack trace, Debugger, Profile 이 모두 스레드 기반

### virtual Thread는?
- virtual Thread의 Threading model 그림
	- 요청당 Platform Thread가 아닌 Virtual Thread를 한개 사용함
	- blocking 발생시 OS context switching이 아닌, continueation 재실행으로 cost가 싸다

### 비교
- platform thread, virtual thread의 memory, context switching cost, size 비교 그림


## Virtual Tread 동작 원리
### continuation
- Virtual Thread는 Runnable Task를 Continuation으로 래핑해서 사용
- 래핑하면 장점이 뭐냐?
	- 실행가능
	- 중단가능
	- 재실행가능
### park, unPark
- LockSupport.park
- LockSupport.unPark
	- unpark시 carrier thread를 할당해줌
### Spring에서 Virtual Tread
- spring.threads.virtual.enabled 로 설정가능
- EmbeddedWebServerFactoryCustomizerAutoConfiguration.class에서 설정됨
- AbstractEndpoint::processSocket에서 excuter 만들어서 처리한다

### 주의점
#### thread local
-> 자식 쓰레드에서 Thread로컬을 사용시 부모스레드의 Thread local을 복사해서 사용
-> 메모리가 너무 커질 수 있음
-> 대안 scoped value, 메모리를 복사하는 것이 아닌, 자식 스레드에서 부모 스레드의 scoped value를 참조 가능
- https://devel-repository.tistory.com/68
#### pinning
- synchronized
	- jni함수로 java level이 아닌, native code임
	- https://jaeyeong951.medium.com/virtual-thread-synchronized-x-6b19aaa09af1
	- synchornized내에서 blocking메서드가 있을때
	- synchronized가 아닌, synchronized를 사용시 synchronized 내부에서 blocking메서드가 있으면 unmount가 안되기 떄문에 비추함
	- synchronized관련해서는 추후에 수정될 수 있다고 함 jep-444
- navtive method
	- 바로 실행가능한 코드
- pinning 감지를 위한 옵션
- `-Djdk.tracePinnedThreads=short`

#### no pooling 
- 생성비용이 싸기에 풀링으로 관리하는 것보다는 필요할때마다 생성하는것이 더 효율적임
	- 풀링으로 관리하면 상태관리를 해줘야하기 때문


도입이 가능할까?
- 모든 서버가 현재 aurora에서 데이터를 가져오고 있다
- Mysql connector j를 사용해서 통신을하는데, Mysql connector j에서 해당 피쳐는 9.0에 공개 예정이고, 9.0공개는 정해지지 않았음



---

virtual Thread 동작 원리
continuation
carrier, 
park unpark

virtual thread의 작업단위 : task

주의점
thread local
-> 자식 쓰레드에서 Thread로컬을 사용시 부모스레드의 Thread local을 복사해서 사용
-> 메모리가 너무 커질 수 있음
-> 대안 scoped value, 메모리를 복사하는 것이 아닌, 자식 스레드에서 부모 스레드의 scoped value를 참조 가능
- https://devel-repository.tistory.com/68
syncronized
-> jni함수로 java level이 아닌, **내부코드임**
-> https://jaeyeong951.medium.com/virtual-thread-synchronized-x-6b19aaa09af1
-> synchornized내에서 blocking메서드가 있을때
-> synchronized가 아닌, synchronized를 사용시 synchronized 내부에서 blocking메서드가 있으면 unmount가 안되기 떄문에 비추함
-> synchronized관련해서는 추후에 수정될 수 있다고 함 jep-444

- pinning 감지를 위한 옵션
- `-Djdk.tracePinnedThreads=short`


poolling하지 마라
-> 따로 풀링하는 케이스는 잘 없고, tomcat에서 하는 경우가 많을텐데, tomcat에서는 사용시마다 새로운 vt를 사용하니 걱정없을것이라 판단됨

jni call은 불가능하다고 봄, java 코드가 실행되는 것이 아닌, 다른 언어의 코드가 실행되는 것이기에 java에서 통제를 못하는 것이 아닌가 생각됨


풀링

더파이러츠에서 사용 가능할까?
모든 서버가 현재 aurora에서 데이터를 가져오고 있다
Mysql connector j를 사용해서 통신을하는데, Mysql connector j에서 해당 피쳐는 9.0에 공개 예정이고, 9.0공개는 정해지지 않았음







20분
