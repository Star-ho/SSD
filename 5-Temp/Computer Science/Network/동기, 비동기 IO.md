---
created: 2023-10-04T22:33:22
updated: 2024-03-03T11:41
---
동기IO는 커널에 마련된 소켓 버퍼에 1차로 Copy하고, 그뒤로 유저 버퍼로 Copy하는 식의 2번의 버퍼드 메모리 액세스? 가 일어나는데

비동기IO는 유저 버퍼에 페이지락을 걸고 다이렉트로 쏴버려서 1번의 카피를 생략 합니다

근데 이게 대용량 데이터 송수신이 아니면 오히려 비동기IO가 훨씬 느린 현상이 나타나곤 합니다

sync io vs async io in kernel level
로 google 검색

https://medium.com/nerd-for-tech/what-is-asynchronous-i-o-b37994359471

https://lwn.net/Articles/216200/

https://etloveguitar.tistory.com/140

https://www.youtube.com/watch?v=vorIqiLM7jc&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=13

아래는 bard답변

네, 물론입니다.

CPU 레벨에서 blocking I/O가 일어나는 과정을 간단히 설명하면 다음과 같습니다.

1. 프로세스는 운영체제에 I/O 작업을 요청합니다.
2. 운영체제는 프로세스의 요청을 받아서 I/O 작업을 시작합니다.
3. I/O 작업이 완료되면 운영체제는 프로세스에 알림을 보냅니다.
4. 프로세스는 알림을 받고 I/O 작업의 결과를 처리합니다.

이 과정에서 프로세스는 I/O 작업이 완료될 때까지 CPU를 사용하지 않습니다. 이는 I/O 작업이 운영체제에서 수행되기 때문입니다. 따라서 I/O 작업이 완료될 때까지 CPU를 다른 작업에 사용할 수 있기 때문에 성능이 향상될 수 있습니다.

다음은 CPU 레벨에서 non-blocking I/O가 일어나는 과정을 간단히 설명하면 다음과 같습니다.

1. 프로세스는 운영체제에 I/O 작업을 요청합니다.
2. 운영체제는 프로세스의 요청을 받아서 I/O 작업을 시작합니다.
3. I/O 작업이 완료되지 않으면 운영체제는 프로세스에 알림을 보냅니다.
4. 프로세스는 알림을 받고 I/O 작업의 결과를 처리합니다.

이 과정에서 프로세스는 I/O 작업이 완료될 때까지 CPU를 계속 사용합니다. 이는 I/O 작업이 완료될 때까지 이벤트를 기다리기 때문입니다. 따라서 I/O 작업이 완료될 때까지 CPU를 다른 작업에 사용할 수 없기 때문에 성능이 저하될 수 있습니다.

또한, non-blocking I/O는 I/O 작업이 완료될 때마다 스레드 스위칭이 발생할 수 있습니다. 이는 I/O 작업이 완료되면 이벤트를 처리하기 위해 다른 스레드로 제어권이 전달되기 때문입니다. 따라서 I/O 작업이 완료될 때마다 스레드 스위칭이 발생하면 성능이 저하될 수 있습니다.

결론적으로, 1개의 HTTP 요청을 보낼 때는 blocking I/O가 CPU 사용량이 낮고 스레드 스위칭이 없기 때문에 non-blocking I/O보다 성능이 우수합니다. 이는 CPU가 I/O 작업이 완료될 때까지 대기하지 않고 다른 작업을 수행할 수 있기 때문입니다.