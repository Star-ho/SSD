---
created: 2023-10-31T22:21:18
updated: 2024-03-03T11:41
---
RabbitMQ는 기본적으로 메시지가 컨슈밍되면 메시지 큐에서 사라지지만, durable 옵션을 통해 메시지를 영구적으로 보관할 수 있습니다. 이 경우, 메시지가 컨슈밍되지 않더라도 메시지 큐에 남아 있게 됩니다.

그러나, RabbitMQ는 durable 옵션을 사용하면 메시지 큐가 비효율적으로 작동할 수 있습니다. 메시지가 컨슈밍되지 않더라도 메시지 큐에 남아 있기 때문에, 메시지 큐의 크기가 커질 수 있고, 메시지 큐를 관리하기 어려울 수 있습니다.

카프카는 기본적으로 메시지가 영구적으로 보관됩니다. 카프카는 메시지를 컨슈밍하지 않더라도 메시지 큐에 남아 있게 되며, 메시지 큐의 크기를 조절할 수 있습니다. 따라서, 메시지를 영구적으로 보관해야 하는 경우, 카프카가 더 적합한 선택일 수 있습니다.

RabbitMQ는 브로커와 컨슈머간의 결합도가 높다고 하는 이유는 다음과 같습니다.

RabbitMQ는 메시지를 큐에 저장하고, 큐에 있는 메시지를 컨슈머가 가져가는 방식으로 작동합니다. 따라서, 컨슈머는 특정 큐에 연결되어야만 메시지를 가져올 수 있습니다.

RabbitMQ는 메시지를 큐에 저장할 때, 메시지의 exchange와 routing key를 지정합니다. 컨슈머는 exchange와 routing key를 지정하여 메시지를 수신할 수 있습니다.

이러한 방식으로 인해, 브로커와 컨슈머는 서로 의존하게 됩니다. 컨슈머가 특정 큐에 연결되어 있지 않으면, 해당 큐에 있는 메시지를 가져올 수 없습니다. 또한, 메시지의 exchange와 routing key가 변경되면, 컨슈머는 메시지를 수신하지 못할 수 있습니다.

카프카는 브로커와 컨슈머간의 결합도가 낮다고 하는 이유는 다음과 같습니다.

카프카는 메시지를 토픽에 저장하고, 토픽에 있는 메시지를 컨슈머가 가져가는 방식으로 작동합니다. 따라서, 컨슈머는 특정 토픽에 연결되어 있지 않아도, 해당 토픽에 있는 메시지를 가져올 수 있습니다.

카프카는 메시지를 토픽에 저장할 때, 메시지의 key를 지정합니다. 컨슈머는 key를 지정하여 메시지를 수신할 수 있습니다.

이러한 방식으로 인해, 브로커와 컨슈머는 서로 독립적으로 작동할 수 있습니다. 컨슈머가 특정 토픽에 연결되어 있지 않아도, 해당 토픽에 있는 메시지를 가져올 수 있습니다. 또한, 메시지의 key가 변경되어도, 컨슈머는 메시지를 수신할 수 있습니다.

카프카를 사용하는 이유는 다음과 같습니다.

메시지 전송의 신뢰성: 카프카는 메시지를 영구적으로 보관하고, 메시지를 순서대로 전송합니다. 따라서, 메시지 전송의 신뢰성을 높일 수 있습니다.

고성능: 카프카는 대규모 메시지 전송을 지원합니다. 따라서, 실시간 데이터 스트리밍이나 로그 수집과 같은 고성능 애플리케이션에 적합합니다.

확장성: 카프카는 수평 확장이 가능합니다. 따라서, 트래픽 증가에 따라 시스템을 확장할 수 있습니다.

이 외에 카프카를 사용하는 이유는 다음과 같습니다.

분산 처리: 카프카는 메시지를 분산하여 처리할 수 있습니다. 따라서, 대규모 데이터 처리를 위한 분산 처리 시스템을 구축할 수 있습니다.

실시간 데이터 분석: 카프카는 실시간으로 데이터를 수집하고 분석할 수 있습니다. 따라서, 실시간 데이터 분석 애플리케이션을 구축할 수 있습니다.

카프카에 대한 자세한 내용은 다음과 같은 리소스를 참고하세요.

Apache Kafka: https://kafka.apache.org/

[Kafka for Beginners](https://kafka.apache.org/