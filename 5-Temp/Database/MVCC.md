---
date: 2023-09-17T22:43:30
updatedAt: 2024-04-21 18:34:36+0910
tags: 
---
저 InnoDB의 MVCC라는 개념을 lock을 피하기 위해 레코드를 버저닝하는 전략이라고 이해했는데요, 그러면 MVCC는 COMMITED_READ / REPEATABLE_READ 이렇게 2가지 격리 수준에서만 적용된다고 생각할 수 있을까요?

이렇게 생각한 이유는
UNCOMMITED_READ 같은 경우에는 실제로 실험해 봤는데 MVCC가 아예 동작하지 않는 것처럼 동작하더라고요. 트랜잭션 A에선 레코드 Z를 수정하고, 트랜잭션 B에선 Z를 읽었는데 수정된 값이 읽혀지는 걸 확인할 수 있었습니다. SERIALIZABLE 에서는 트랜잭션간 침범이 아예 불가능하기 때문에 lock을 전제로 까는 전략이라 적용되지 않는다고 생각했습니다.

--- 

또 궁금한 점은 혹시 그럼 UNCOMMITED_READ 수준을 사용하는 경우에는 트랜잭션에서 직접 s-lock 걸어서 제어하는 식으로 정합성 관리하게 되나요...? 현업에선 어떻게 처리하시는지 궁금합니다

---

MySQL 기준으로 넵 커밋티드랑 리피터블 격리 래밸에서만 사용되는게 맞구, 이 둘의 차이는 트랜잭션에서 처음 Select 요청을 보냈을 때 생성된 스냅샷을 재사용하느냐 아니냐의 차이라고 생각하시면 될 것 같아요 

데이터 수정시마다 이전 기록은 롤백, 언두 세그먼트 형태로 기록되고 더블 링크드 리스트 형태로 체이닝되어 관리되는데 그걸 현재 시작한 trx id를 보고 접근해서 readview를 만드는 형식이라고 하더라구요

---
아예 시리얼라이즈블하게 전체 영역에 락을 거는 형태로 다뤄야 안읽힐건데(애초에 다른 세션은 시작도 못하니까) 그럼 언커밋티드를 쓰는게 맞나 싶긴해요

#Infrastructure 
#Database 