---
date: 2024-03-31T22:41:00
updatedAt: 2024-04-21 18:32:05+2670
tags: 
---
pt-osc 나 gh-ost 같은 온라인으로 DDL이 가능한 툴을 사용해보시면 어떨까요

힌트 감사합니다 ㅎ 전략의 원리? 가 궁금했어요
말씀주신 툴을 검색해보니 덤프용 테이블을 만들고
trigger dml 걸고 덤프에서 ddl 을 수행하나보네요
이런방법이 가장 커먼한건지 궁금하네요 ㅎㅎ

algorithm inplace를 한번 찾아보시는것도 좋을것 같네요.

테이블 크기가 얼마나 되나요? 그리고 부하가 높다눈 건 어느정도에요?

실제 운영에서 나온이슈는 아니에요 ㅎ 면접질문으로 받은거였어요 수천만건 테이블이고, 실시간으로도 수천건씩 계속 CRUD 도 진행되기도 하는 테이블인데, 서비스 운영에 문제 없도록 스무스 하게 인덱스를 걸려면 어떤 방법이 있나? 

없지 않나요..? 저희는 테이블에 row가 500만 ~ 1억개라... 저도 궁금하네요

공식문서를 보면, 인덱스 타입 변경만 algorithm instant를 지원하는걸로…

아니지, instant는 add index에 안 되는걸로 알고 있습니다.

세컨더리 인덱스 추가, 삭제 등은 instant 미지원..

https://dev.mysql.com/doc/refman/8.0/en/InnoDB-online-ddl-operations.html

질문하신분의 면접때 상황설정이
수천만건의 데이터가 있고 수천건의 cud가 발생한다는 가정이었으니
inplace는 어렵지 않을까 싶은거였습니다.
제가 유사 상황에서 실제로 인덱스 생성을 해 봤는데 장애났습니다. ㅠㅠ

inplace 알고리즘도 결국에 테이블에 인덱스를 한번에 생성해야해서 극단적으로 거대한 데이블이라는 명제가 붙으면 사용하기 어려울 꺼에요. pt-osc로 throttling을 해주면 잘 될 거라고 생각합니다 

인덱스를 생성하는 시간 동안 변경사항이 발생하면 마지막에 잠시 락잡는게 길어지게 됩니다.
이부분이 얼마나 될 지 예측이 불가한데요.
그런 위험성을 안고 실시간으로 많이 사용되는 테이블에 일반 생성구문을 사용하는 것보다
disk 용량 및 io가 여유가 있는 사전 확인 후  pt-osc를 사용할 것 같습니다.

어떤 매커니즘으로 락이 걸리는 걸 말씀하시는 걸까요?

Metadata lock잡고 작업시간동안 누적된 변경분 적용하는거요

mdl은 매우 빨라서 괜찮을 것 같습니다 

Lock none도 마찬가지로 마지막에 락 잡는건 동일하지않나요?