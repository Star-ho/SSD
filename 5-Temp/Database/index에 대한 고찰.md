---
date: 2024-05-07 22:44:05
updatedAt: 2024-05-07 22:44:10
---
안녕하세요. 저는 백엔드 개발자를 준비중인 학생입니다. 1권 인덱스 쳅터를 읽는 중 B-Tree 인덱스를 통한 데이터 읽기 방법을 직접 눈으로 확인해보고 싶어 실습을 진행해보다가 궁금한점이 생겨글을 남겨봅니다. 실습을 위해 USER라는 테이블을 만들고 50만건의 데이터를 만들어 테스트 해봤습니다.

"SELECT age, MIN(name) FROM USER GROUP BY age;" 라는 쿼리에 대해서 3가지 경우를 테스트 해봤습니다.

1 : index 걸지 않은 경우 : 0.18초
2 : age에 index를 걸은 경우 : 0.34초
3 : (age, name)에 index를 걸은 경우 : 0.00초

처음에는 2번(age 에만 인덱스를 건 케이스)이 1번(인덱스를 걸지 않은 케이스)보다 시간이 오히려 오래 걸리는 것을 보고 "인덱스를 잘못걸면 안거는 것보다 못하구나!" 라는 결론을 내렸습니다.
그러다 저보다 DB를 더 잘 아시는 분이 
### "쿼리의 성능을 결정하는건 시간뿐만이 아니다. cpu와 메모리 자원 사용량 또한 쿼리의 성능을 측정하는 척도로 사용되어야 한다." 
라는 조언을 해주셨습니다. 그 후 1번의 EXPLAIN ANALYZE를 보니 임시 테이블을 생성해서 쿼리를 수행했다는 것을 보고 "메모리와 cpu가 더 사용되었겠구나. " 라는 것을 깨달았습니다. 

제가 궁금한 것은 다음과 같습니다.
- 위 문단의 내용이 적절한지 여부
- 2번과 1번의 쿼리의 cpu와 메모리 사용량을 확인할 수 있는 좋은 방법
이 두가지가 궁금합니다.
![600](Pasted%20image%2020240507224632.png)

![600](Pasted%20image%2020240507224650.png) 

![600](Pasted%20image%2020240507224703.png)

![600](Pasted%20image%2020240507224723.png)
---

말씀하신대로 cpu와 메모리를 과도하게 쓰면서 근소하게 빠른 경우는(오라클의 경우 머지소트가 있겠네요) 보통 지양하죠.
프로파일링을 보시면 좋을것같구요 (https://dev.mysql.com/doc/refman/8.0/en/show-profile.html)
analyze에 정보가 나와있는대로, 같은 조건들로 해당 쿼리에 limit 1을 해보시면 또 다른 결과를 보실수도 있을겁니다~

---
요기에서 좀 생각이 필요한 부분이 "쿼리의 성능을 결정하는건 시간뿐만이 아니다. cpu와 메모리 자원 사용량 또한 쿼리의 성능을 측정하는 척도로 사용되어야 한다."라는 부분인데요. 얼핏보면 그럴듯 한 이야기인데, 또 한편으로 생각해보면, 쿼리 시간이 느린 이유가 뭐일까에요. 쿼리 시간이 느리면 느린 만큼 cpu를 사용했거나 기타 자원(메모리나 디스크 등등)을 그만큼 사용했기 때문이 아닐까요 ? 쿼리 2개가 있는데, 1번 쿼리는 1초가 걸렸고 2번 쿼리는 2초가 걸렸을 때, 2번 쿼리가 시스템 자원을 덜 사용하면서 시간이 오래 걸린 경우가 어떤 경우일까요 ? 딱 하나있는데, thread sleep만 많이 한 경우일텐데, 이 경우는 2가지로 구분해볼 수 있는데 1) 의도적으로 user sleep을 넣은 경우와 2) cpu busy sleep을 많이 한 경우인데, 후자는 사실 잠금 대기로 인해서 cpu busy wait을 한 경우일 걸로 보여요. 2번은 의도치 않은 경우이거나 성능 이슈가 있는 경우이니,,, 적절한 경우가 아닌거죠.

쿼리는 parallel로 처리되면서 처리 시간이 빨리 끝난 것을 배제한다면, (제 개인적인 생각으로는) 처리 시간이 빠를수록 효율적이라고 생각되어져요

---

저도 이 부분이 너무 궁금했는데요
 
CPU 사용량 / Disk IO / 쿼리 수행시간
요 세가지가 절대적으로 비례하지 않는다고 최근에 느꼈는데 말씀하신 것과 같은 이치일까요? 수행시간이 길다면 긴 이유가 저기 두가지 원인(CPU / Disk IO)이 있을테고.. 또 두가지는 서로 비례할 것 같은데.. 이게 또 절대적이진 않다는 생각이 들어서요..

--- 

두번째 질문에 대한 답변을 드리기 전에, 쿼리 하나가 실행되는데 있어서 필요한 cpu와 메모리 사용량을 측정하는 부분은... 
cpu 사용량은  memory 사용량(둘다 필요한 시점에 사용량이 주욱 올랐다가 쿼리가 완료되면 다시 초기화되는 패턴이기 때문에), performance schema의 events_statements_과 memory_summary_by_를 이용해서 cpu 사용량과 메모리 사용량을 예측해볼 수 잇지 않을까 싶네요.

근데, 이런 방식보다 쿼리가 처리되는 실행 계획을 보면, 대략적인 복잡도를 예측할 수 있는데... 1번은 별도의 메모리 또는 디스크 공간을 할당받아서 Sorting을 하고 grouping을 해야 하는 반면, 3번 쿼리는 그런 부가적인 작업없이 인덱스만 순서대로 읽으면 원하는 결과를 만들 수 있습니다. 이것만 봐도 1번 대비 3번 쿼리가 훨씬 (레코드 건수가 많아질수록) 더 효율적일것으로 예측할 수 있죠.

정확한 메모리 & cpu 사용량의 측정이 큰 의미가 없을 수도 있을 것 같아요.